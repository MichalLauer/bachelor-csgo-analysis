---
title: "Analýza dat pro Bakalářskou práci"
author: "Michal Lauer"
date: '2022-04-10'
output:
  html_document:
    css: style.css
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    df_print: paged
    theme: cosmo
    highlight: haddock
editor_options: 
  chunk_output_type: console
---
# Funkce a globální nastavení

## Knihovny
```{r libraries}
library(readr)
library(dplyr)
library(stringr)
library(tidyr)
library(runner)
library(ggplot2)
library(GGally)
library(kableExtra)
library(paletteer)
```

## Nastavení
```{r global-options, message=F}
knitr::opts_chunk$set(message = F)
theme_set(theme_minimal())
```

## globální proměnná maps
Mapy, pro které se počítají statistiky
```{r maps}
maps <- c(
  "Dust2", "Inferno", "Vertigo", "Overpass", "Nuke", "Mirage",
  "Train", "Cache", "Cobblestone"
)
```

## Ukládání pro bakalářskou ráci
```{r bc}
bc.code_dir <- "../bakalarska-prace/kod/"
if (!dir.exists(bc.code_dir)) dir.create(bc.code_dir)

bc.pictures_dir <- "../bakalarska-prace/obrazky/"
if (!dir.exists(bc.pictures_dir)) dir.create(bc.pictures_dir)
```

## funkce clear_player_map
Funkce slouží k extrakci statistik hráčů pro dané pořadové číslo
mapy v zápase
```{r clear_player_map}
#' Dataset contains statistics for all maps in one row.
#' Function recieves players tibble and a number of a map. The output
#' is a tibble that splits the statistics and each row contains 
#' stats for a given map, no matter the number.
#'
#' @param tbl Tibble of players
#' @param map Number of a map. Can be one, two, or three
#'
#' @return Tibble with statistics for a given map
clear_player_map <- function(tbl, map) {
  m_ <- sprintf("m%i_", map)
  tbl |>
    select(match_id,
      player_id,
      team,
      # Select statistics regarding specified map
      map = sprintf("map_%i", map),
      matches(sprintf("^m%i_", map))
    ) |>
    # matches only aggregated statistics for specified map
    # e.g. excludes m1_kills_ct, m1_kills_t and keeps only m1_kills
    select(!matches("_c?t$")) |>
    drop_na(map) |>
    # Unify names, e.g. m1_kills -> kills
    rename_with(
      .cols = starts_with(m_),
      .fn = ~ str_remove_all(.x, m_)
    ) |>
    # remove columns that are only calculated from other columns
    # or are troublesome because of the website history tracking
    select(-c(kddiff, flash_assists, kast, adr)) |>
    # make HS relative and not absolute
    mutate(hs = ifelse(kills == 0, 0, hs / kills))
}
```

## funkce clear_results_team
Funkce pro získání $i$-tého týmu z tabulky výsledků
```{r clear_results_team}
#' The source data frame contains team_1 and team_2 in results.
#' This method returns a tibble with data for team_1 or team_2
#' with the correct match results
#'
#' @param tbl Tibble with results
#' @param i Team number, can be either one or two
#'
#' @return Tibble with results for i-th team
clear_results_team <- function(tbl, i) {
  tbl |>
    select(
      date,
      match_id,
      team = matches(sprintf("team_%i", i)),
      map,
      map_winner,
      starting_ct,
      team_rank = matches(sprintf("rank_%i", i))
    ) |>
    filter(map %in% maps) |>
    mutate(
      map_winner = as.numeric(map_winner == i),
      starting_ct = as.numeric(starting_ct == i)
    )
}
```

## funkce geom_mean
Funkce pro vypočtení geometrického průměru dle https://en.wikipedia.org/wiki/Geometric_mean
```{r geom_mean}
#' Compute geometric mean. Helps with statistics such as HS or Rating
#' Funstion uses log transformation because the ongoing calculations
#' were small and R couldn't handle them.
#' 
#' @param x Number vector
#'
#' @return Geometric mean
geom_mean <- function(x) {
  exp(sum(log(x)) / length(x))
}
```

## funkce save_bc_code
Pro uložení mezivýpočtů a textu pro účely bakalářské práce
```{r save_bc_code}
save_bc_code <- function(tbl, f, cap, lab) {
  f <- file(paste0(bc.code_dir, f),
    encoding = "UTF-8"
  )
  
  tbl |>
    kbl(
      format = "latex",
      caption = cap,
      label = lab,
      align = "c",
      valign = "t",
      position = "H",
      centering = T
    ) |>
    kable_styling(latex_options = "scale_down") |> 
    writeLines(con = f)
  close(f)
}
```

## funkce save_bc_picture
Pro uložení obrázků z balíčku ggplot2
```{r save_bc_picture}
save_bc_picture <- function(g, f) {
  ggsave(
    paste0(bc.pictures_dir, f),
    plot = g,
    bg = "white",
    width = 140,
    height = 105,
    units = 'mm'
    )
}
```

# Nahrání dat

## economy.csv
Jelikož se predikce soustředí na předpovídání výsledku ještě než zápas začal,
informace o vývoji ekonomiky jednotlivého teamu v zápasu není potřeba a soubor
*economy.csv* se nevyužije.

## picks.csv
Dataset *picks.csv* obrahuje pořadí, v jakých týmy proti sobě banovali či vybírali
mapy. Tato informace by byla podstatná v případě simulace zápasu
mezi dvěma tými. Jelikož se ovšem jedná pouze o předpověd výsledku
zápasů, dataset není použít.

## players.csv
Soubor *players.csv* obsahuje detailní statistiky hráčů v jednotlivých zápasech.
Jeden řádek obsahuje statistiky pro jeden zápas, ale pro všechny mapy
(resp. jednu, dvě, nebo tři).
```{r players.raw}
players.raw <- read_csv("data/players.csv", show_col_types = F)

# Get only matches where we have data for all 10 players
players.raw <- players.raw |>
  group_by(match_id) |> 
  filter(n() == 10)

players.raw |>
  slice_sample(n = 10) |>
  print()

# Bachelor save
players.raw |> 
  names() |> 
  matrix(ncol = 4) |> 
  save_bc_code(
    f = "players_csv_puvodni.tex",
    cap = "Sloupce v původní struktuře datového souboru players.csv",
    lab = "players.csv_puvodni"
  )

```

Pro potřeby logistické statistiky za zápas a mapy musí sjednotit.
Model nebude brát v potaz, zda se mapa hraje jako první, druhá, či
třetí. Proto se data transformují do formátu, kde jeden řádek popisuje
statistiky jednoho hráče na jedné mapě. Reprezentace statistik
jednoho hráče v jednom zápase je tedy rozdělena na více řádků. Z 
datasetu se následně vyloučí nepotřebné mapy a použijí se pouze
zápasy, ve kterých máme statistiky pro všech 10 hráčů.
```{r players}
players <- clear_player_map(players.raw, 1) |>
  rbind(clear_player_map(players.raw, 2)) |>
  rbind(clear_player_map(players.raw, 3)) |>
  filter(map %in% maps) |>
  drop_na() |> 
  group_by(match_id) |>
  # Delete matches which do not contain 10 players in total
  # A propper match_id can have 10 (Bo1), 20 (Bo2), or 30 (Bo3) rows
  filter(n() %% 10 == 0) |>
  ungroup()
```

Pro interpretaci dat použijeme první řádek z transformovaného
datasetu
```{r players-interpretation}
r <- players[3, ]
save_bc_code(r,
        f = "players_csv_transformovano.tex",
        cap = "Záznam z transformovaného datového souboru players.csv",
        lab = "players_csv_transformovano")
r
```


- **match_id** - Identifikátor zápasu
- **player_id** - Identifikátor hráče
- **team** - Jméno týmu, za které hráč v zápase hrál
- **map** - Mapa, na které se zápas odehrál
- **kills** - počet zabití daného hráče na mapě
- **assists** - počet asistencí daného hráče na mapě
  - hráč nepřítele nezabil, ale udělil mu velké poškození
- **deaths** - počet smrtí daného hráče na mapě
- **hs** - procento, kolik zabití bylo tzn. headshotem
  - v případě že hráč zabije nepřítele střelou do hlavy
- **fkdiff** - rozdíl mezi prvním zabitím a první smrtí
  - pokud hráč jako první zabil nepřítele, pričte se jedna. Pokud
  hráč jako první umřel, odečte se jedna
- **rating** - rating hráče v daném zápasu
  - rating je vypočítán stránkou [hltv.org](https://www.hltv.org/)

## results.csv
Poslední datový soubor *results.csv* obsahuje tu nejdůležitější
proměnou, a to výsledek daného zápasu. Z datasetu je nutné
vyloučit chybné záznamy, kde team hrál sám proti sobě. Zároveň je
zde smazaný tým s otazníčkem.
```{r results.raw}
results.raw <- read_csv("data/results.csv",
  show_col_types = F,
  col_select = c(date, team_1, team_2,
    map = "_map", map_winner,
    starting_ct, rank_1, rank_2, match_id
  )
) |>
  # Incorrect data when team played against itself
  filter(team_1 != team_2,
         team_1 != "?", team_2 != "?")
```

Podobně jako se souborem *players.csv*, i zde každý řádek reprezentuje
více statistik. Zde to je výhra, resp. prohra, daného teamu. Je nutné
proto dataset transformovat do formátu, kde každý zápas bude mít dva 
řádky. Jeden pro výherní tým (**map_winner = 1**) a druhý pro
tým co prohrál (**map_winner = 0**). Jelikož team mohl mít
v zápase jiný rank, výsledný rank, je spočítán průměrný rank týmu
za poslední 3 měsíce.
```{r results, cache=TRUE}
results <- clear_results_team(results.raw, 1) |>
  rbind(clear_results_team(results.raw, 2)) |> 
  group_by(team) |> 
  arrange(date, .by_group = T)

# Takes approx. 3,5 mins
results <- results |>
  mutate(run_mean_3_months = runner(
    x = results,
    k = "3 months",
    f = function(tbl) {
      mean(tbl$team_rank)
    },
    idx = "date"
  )) |>  
  ungroup()

r <- results[4,  ]
save_bc_code(
  r,
  f = "results_csv_transformovano.tex",
  cap = "Příklad záznamu z transformovaného datového souboru results.csv",
  lab = "results_csv_transformovano"
)
r
```

Interpretace je následující:

- **date** - Datum zápasu
- **match_id** - Identifikátor zápasu
- **team** - Jméno týmu
- **map** - Hraná mapa
- **map_winner** - Ukazuje, zda tým zápas vyhrál
- **starting_ct** - Ukazuje, zda tým začal za CT (Counter-Terrorists) 
nebo T (Terrorists)
- **team_rank** - Rank týmu v dobu, kdy se zápas odehrál
- **run_mean_3_months** - Průměrný rank týmu za poslední 3 měsíce

# Explorační analýza dat
Explorační analýza dat slouží ke grafickému zobrazení datasetu.

## Statistiky hráčů v zápasech
Může být zajímavé, jaká mapa se hraje nejčastěji, a která je naopak
mezi hráči není oblíbená. Jelikož se jedná a porovnání kvalitativní a
kvantitativní proměnné, je nejrozumnější použít sloupcový graf.
```{r ggplot-matches-per-map}
g <- players |> 
  count(map) |> 
  mutate(n = n/10) |> 
  ggplot(aes(x = reorder(map, n), y = n, fill = map)) +
  geom_col(show.legend = F) +
  scale_y_continuous(labels = scales::comma) +
  coord_flip() +
  theme(
    panel.grid.major.y = element_blank()
  ) +
  labs(
    title = "Počet zápasu na každé mapě",
    x = "Mapa",
    y = "Počet zápasů"
  )

save_bc_picture(g, "zapasy_pres_mapu.png")
g
```

Z grau jde pozorovat, že s velkým náskokem je nejoblíbenější mapa
Mirage. Je to mapa, která nejdelší dobu nedostala velký update a mezi
hráči je i přes to stále na prvním místě. Na druhé straně je mapa 
Vertigo, která je v map poolu krátký čas. Je to úplně nová mapa a
hráči na ni nejsou ještě tolik zvyklí, nemají naučeno mnoho strategií
a nejsou zde oběveny ještě všechny triky. Je to oblíbená mapa na 
upsety (horší tým porazí lepší), proto se mapě můžou zkušenější týmy
vyhýbat.

## Distribuce zabití
Pro zobrazení distribuce zabití l |> ze použít histogram. Data jsou zde
na úrovni jednotlivých hráču, takže se jedná o data za hráče.
```{r ggplot-kills}
bins <- (1 + 3.3 * log10(nrow(players))) |> floor()
mean <- mean(players$kills)
median <- median(players$kills)

g <- players |>
  ggplot(aes(x = kills)) +
  geom_histogram(bins = floor(bins),
                 fill = "grey",
                 color = "black") +
  geom_vline(aes(xintercept = median,
                 color = "medián",
                 linetype = "medián"),
                 size = 1) +
  geom_vline(aes(xintercept = mean,
                 color = "průměr",
                 linetype = "průměr"),
                 size = 1) +
  scale_color_manual(
    values = setNames(
      paletteer_d("ggthemes::wsj_red_green"),
      c("průměr", "medián")
      )
    ) +
  scale_linetype_manual(
    values = c("průměr" = "dotted",
               "medián" = "dotdash")
  ) +
  scale_y_continuous(labels = scales::comma,
                     breaks = seq(0, 175000, by = 25000)) +
  scale_x_continuous(breaks = seq(0, 80, by = 4)) +
  theme(
    panel.grid.minor.x = element_blank(),
    panel.grid.minor.y = element_blank(),
    axis.line.x = element_blank(),
    legend.position = "bottom"
  ) +
  labs(
    title = "Distribuce zabití v každém zápase",
    subtitle = sprintf("Průměr: %.2f, Medián: %.2f", mean, median),
    x = "Počet zabití",
    linetype = "Statistika",
    colour = "Statistika"
  )

save_bc_picture(g, f = "histogram_zabiti.png")
g
```

Hostogram má normání rozdělení s dlouhým skloněním doprava. To je z
toho důvodu, že existují speciální případy s 44+ zabitími za zápas.
To může nastat např. v prodloužní, kdy se hraje více kol než v
základním čase.

## Boxplot ratingu hráče
Rating hráčů je statistika zprostředkovaná portálem
[hltv.org](https://www.hltv.org/news/20695/introducing-rating-20).
Jedná se kombinaci mnoha statistik do jedné metriky, díky které
se dá ohodnit výkon hráče v daném zápase.
```{r boxplot-rating}
g <- players |> 
  semi_join(
    results |> 
      filter(map_winner == 1),
    by = c("match_id", "team", "map")
  ) |> 
  ggplot(aes(x = reorder(map, rating, FUN = stats::median),
             y = rating, color = map)) +
  geom_boxplot(show.legend = F, outlier.shape = 1,
               alpha = 0.4) +
  scale_y_continuous(breaks = seq(0, 4, by = 0.25),
                     limits = c(0, 3.5)) +
  theme(
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  coord_flip() +
  labs(
    title = "Distribuce ratingu ve vítězných zápasech přes kategorii mapy",
    subtitle = "Seřazeno dle mediánu každé kategorie",
    x = "Mapa",
    y = "Rating"
  )
  
save_bc_picture(g, f = "boxplot_ratingu.png")
g
```

Z box plotů nelze usoudit, že by se rozdělení nějak zásadně lišlio
ať v mediánu, tak v mezikvartilové šírce. Jednotlivé mapy jsou
pak charakterizováný delšími ocasy vpravo.

## Korelace mezi prediktory
Pro regresy je důležité zjistit, zda nejsou prediktory korelované. To
lze u kvantitativních prediktorů zjistit pomocí korelační tabulky.
```{r ggplot-correlation}
g <- players |> 
  select(kills:rating) |> 
  ggcorr(label = T)
save_bc_picture(g, f = "prediktory_korelace.png")
g
```

Z obrázku jde zjistit, že proměnná rating je silně korelovaná se 
statistikou kills a fkdiff. Z tohoto důvodu je prediktor z dalších
analýz vyloučen.

# Modelování
V modelovací části je porovnáno více druhů modelů. První typ předpovídá
to, zda hráč vyhraje či prohraje zápas dle jeho statistik na určité
mapě. V druhém modelu se pak porovnává pravděpodovnost výhry
jednotlivých týmu s interakcí mezi mapou a začínající stranou.
Na konci je představen model jednoho týmu proti nejlepším třiceti
týmum z celého datasetu.

## Model pro individuální hráče
Model pro individuální hráče slouží k popisu pravděpodovnosti, zda
hráč zápas vyhraje či nikoliv. Pravděpodovnost je porovnána na dvou
mapách - Vertigo a Dust2.

### Příprava dat
Prve je nutné dataset se statistikami hráču spojit s výsledky
daných zápasů. Následně jsou odstraněny nepotřebné prediktory i s
korelovaným prediktorem rating.
```{r model.data_per_player}
model.data.per_player <- players |> 
  inner_join(results,
            by = c("match_id", "team", "map")) |>
  select(-c(match_id, player_id, team, date, rating))
```

### Mapa de_vertigo
Pro mapu Vertigo je vytvořen následující model
```{r model.per_player.dust2}
model.data.per_player.dust <- model.data.per_player |> 
  filter(map == "Dust2") |> 
  select(-map)

model.per_player.dust2 <- glm(
  map_winner ~ kills + assists + deaths + hs + fkdiff + 
    starting_ct + team_rank + run_mean_3_months,
  data = model.data.per_player.dust2,
  family = binomial
)

model.per_player.dust2 |> 
  summary()
```

Pro model jsou nevýznamné statistiky fkidff a run_3_mean_months. Z modelu
vyplívá, že mapa je více soustředěna na týmovou sehranost než na 
individuální výkon. Jelikož je statistika fkdiff nesignifikantní,
není důležité, zda hráč jako první umře či zabije - jeho tým se se
situací dokáže vypořádat. Druhý nesignifikantní statistika naznačuje,
že na vítězství nemá vliv to, jaký je průměrný rank týmu. Toto 
potvrzuje hypotézu, že je mapa lepší pro nezkušené týmy.

### Mapa de_inferno
Mapa inferno je více týmová. Je zde důležitá sehranost a zkušenosti.
Zde se dá očekávat, že budou signifikantní všechny statistiky.
```{r model.per_player.inferno}
model.data.per_player.inferno <- model.data.per_player |> 
  filter(map == "Inferno") |> 
  select(-map)

model.per_player.inferno <- glm(
  map_winner ~ .,
  data = model.data.per_player.inferno,
  family = binomial
)

model.per_player.inferno |> 
  summary()
```

Je vidět, že na rozdíl od mapy Vertigo je zde statistika fkdiff velmi
významná. To znamená, že je důležité hrát jako tým a snažit se 
strategicky získat první zabití v daném kole.

### Porovnání modelů
...

## Týmové modely
Modely pro daný tým slouží k přepovědi, zda daný tým vyhraje zápas
či nikoliv. Na rozdíl od modelů pro hráče se zde počítá i s hranou
mapou. Opět je nutné spojit datasety se statistikami hráču a výsledků
zápasu. Nyní je však nutné statistiky agregovat pomocí aritmetického a
geometrického průměru.

### Tvorba dat
Nejdříve se data agregují pro každý zápas, tým a hranou mapu. Následně
se ke statistikám přípojí finální výsledek.
```{r model.data.per_match}
model.data.per_match <- players |>
  # Calculate summary statistics for players per match, team and map
  group_by(match_id, team, map) |>
  summarise(
    mean_kills = mean(kills),
    mean_assists = mean(assists),
    mean_deaths = mean(deaths),
    mean_hs = geom_mean(hs),
    mean_fkdiff = mean(fkdiff),
  ) |>
  ungroup() |>
  # Join match results
  inner_join(results,
    by = c("match_id", "team", "map")
  )
```

### Globální model
Globální model slouží jako model pro všechny týmy. Nebere se zde ohled
na jednotlivce a snaží se určit obecná pravděpodovnost a prediktory
pro všechny týmy najednou.
```{r model.per_match}
model.per_match <- 
  glm(map_winner ~ mean_kills + mean_assists + mean_deaths + 
        mean_hs + mean_fkdiff + run_mean_3_months +
        starting_ct:map,
      data = model.data.per_match,
      family = binomial)

model.per_match |> 
  summary()
```

První zajímavý poznatek lze interpretovat z interkací mezi starting_ct
a mapou. Z koeficientů lze usoudit, že je nevýhodné na většině map
začínat jako Counter-Terroristé - snížuje to šanci na celkovou výhru!.
Dále je zajímavé, že s větším procentem HS klesá pravděpodovnost výhry.
Toto může být vysvětleno případy, kdy má hráč málo zabití. V tomto
případě je poměr zabití a HS větší, než v případě mnoha zabití.

### Model pro tým Liquid
Tento model je specifický na refereční tým ze Severní Ameriky.
```{r model.data.per_match.liquid}
model.data.per_match.liquid <- 
  model.data.per_match |> 
  filter(team == "Liquid")

model.per_match.liquid <- 
  glm(map_winner ~ mean_kills + mean_assists + mean_deaths + 
        mean_hs + mean_fkdiff + run_mean_3_months +
        starting_ct:map,
      data = model.data.per_match.liquid,
      family = binomial)

model.per_match.liquid |> 
  summary()
```

Můžeme vidět že oproti obecnému modelu, pro tým Liquid není podstatné
(až na jendu vyjímku) zda začínají jako Teroristé či Counter-Terroristé.
Z modelu plyne, že
nejpodstatnější statistika pro tým Liquid je počet zabití a počet 
úmrtí. Díky kladnosti a zápornosti koeficientů lze usoudit, že 
s rostoucím počtem průměrného zabití za zápas a klesajícím průměrným
počtem smrtí za zápas roste pravděpodovnsot na výhru.

### Model pro tým eXtatus
Nyní si vytvoříme tým eXtatus, který se skládá z českých a slovenských
hráčů. Je to mimo jiné první tým, který se probojoval na profesionální
světovou scénu.
```{r model.data.per_match.extatus}
model.data.per_match.extatus <- 
  model.data.per_match |> 
  filter(team == "eXtatus")

model.per_match.extatus <- 
  glm(map_winner ~ mean_kills + mean_assists + mean_deaths + 
        mean_hs + mean_fkdiff + run_mean_3_months +
        starting_ct:map,
      data = model.data.per_match.extatus,
      family = binomial)

model.per_match.extatus |> 
  summary()
```

Pro česko-slovenský celek z modelu plyne, že jejich nejvýznamnější
statistika je pouze počet smrtí a počet zabití.

### Porovnání modelů
...

## Tým FaZe vs. top30

### Vytvoření dat
```{r model.versus.data}
reference_team <- "FaZe"
top_30 <- results |> 
  filter(team != reference_team) |> 
  group_by(team) |>
  summarise(mr = median(team_rank, na.rm = T)) |> 
  filter(n() >= 100) |> 
  slice_min(order_by = mr, n = 30) |> 
  pull(team)

versus_match_id <- results.raw |> 
  filter(
    (team_1 == reference_team & team_2 %in% top_30) |
    (team_1 %in% top_30 & team_2 %in% reference_team)
    ) |> 
  distinct(match_id) |> 
  pull(match_id)


model.versus.data <- 
  model.data.per_match |> 
  filter(match_id %in% versus_match_id) |> 
  mutate(faze_win = (map_winner == 1 & team == reference_team))
```

### Model
```{r model.versus}
model.versus <- 
  glm(faze_win ~ mean_kills + mean_assists + mean_deaths + 
        mean_hs + mean_fkdiff +  
        map,
      data = model.versus.data,
      family = binomial)

model.versus |> 
  summary()
```

